##########################################################
#           Compiler options
##########################################################
# Compiler options are set in the main betsy file.

compiler output_c_file true
compiler optimisation_level 3

compiler search_path ./modules
compiler search_path ../dependencies/someLib/modules

compiler lib kernel32.lib

# Include other betsy files using 'using'
using std.betsy
using lists.betsy
using concurrency.betsy
using ./test-package/greeter.betsy

##########################################################
#           Declaring variables
##########################################################
# Declare a variable using 'var'
# A variable has a name, a type and optionally a value.
var a int
var b int 12
var c int * b 2

# Assign a value to a variable using 'set'
set a 4
set b c
set c * * a b c

# 'const' makes a variable constant and cannot be changed
const ARRAY_SIZE int 14
set ARRAY_SIZE 100          # ERROR: cannot assgin a value to a constant


##########################################################
#           Control flow
##########################################################
# Branching with 'if', 'elif', and 'else'
# 'do' and 'end' create a block with a new scope (more in BLOCKS).
# 'If' branch
if < n 16 do
    print "n is smaller than 16"
elif > n 16 do
    print "n is greater than 16"
else
    print "n is equal to 16"
end

# While loop
n = 0
loop n int 0 while < n 20 do
    print n
    n = + n 1
end

while n int 0 < n 20 do
    print n
    n = + n 1
end

# While loop can look a bit like traditional for loops
n = 0 while < n 20 do n = + n 1 
    print n
end

##########################################################
#           Blocks
##########################################################

# 'do' and 'end' create a block with a new scope.
var a int 12
if true do
    set a 144
    var b int 3
end
print a             # 144
print b             # ERROR: b not defined in this scope

# Blocks can be assigned to a variable and can be executed later
# The type of the variable is 'fn <list of input types> out < list of output types> end'
var saved_block fn end      # Variable of type block with no inputs or outputs
set saved_block do          # Assign block to variable
    print "Hello from inside a block"
end

saved_block                 # Executes the block

# Declaration and assignment at the same time
var say_hello do
    print "I say hello to you"
end

# Functions
# Blocks can take inputs and are called functions.
# The block is prepended with its type information and the parameter names
# For variable declaration without assignment the type information has no parameter names.
var greet fn string end
set greet fn name string do
    print & "Hello " name
end
greet "tom"          # 'Hello tom'

# Functions can produce zero or multiple outputs
# The 'out' keyword in the type definition signals the output types
var get_day_and_month fn out number number do
    return 11 12
end
print + get_day_and_month           # 23

#        # MAYBE!
#        # Naked values at the end of a function are automatically returned
#        var square fn x int do
#            * x x
#        end

# Functions can return other functions
var get_greeter fn out fn end do
    return do
        print "I greet you"
    end
end
var greeter fn end get_greeter
greeter                 # 'I greet you'


#        # MAYBE!
#        # 'auto' keyword to infer types
#        var greeter auto get_greeter
#        greeter                 # 'I greet you'

# Closure
# The scope in which a function is defined is preserved for the livetime of the function
var create_counter fn out fn out int end do
    var count int 0        # count is enclosed in the returned function
    return fn out int do
        set count + count 1
        return count
    end
end

var counterA auto create_counter    # creates a new closure
print counterA               # 1
print counterA               # 2
print counterA               # 3
var counterB auto create_counter    # seconds call creates its own closure
print counterB               # 1
print counterB               # 2
print counterB               # 3


##########################################################
#           Others
##########################################################


# Run a function for each element in an iterable
# foreach (iterable(T)) block(T)->() 
foreach list number n do
    print n
end

# Forach knows the type of the block and can act acordingly
# For a map, pass either the key, or key/value pair
print_key string key -> do
    print key
end
foreach map print_key       # Only prints the keys of the map

print_entries string key string value -> do
    print & & key ": " value
end
foreach map print_entries   # Prints key and value pairs


# Map function
# Apply a transform function to each element in an iterable
# map (iterable(T)) block(T)->(U) -> (iterable(U))
transform_function number n -> string do
    return & to_string n ", "
end
list = map list transform_function

# Or more compact
list = map list number n -> string do & to_string n ", " end

# Types can be infered and arguments are named for a very compact statement
list = map list do & to_string a ", " end


# Types
chat        # 1 byte
int         # 4 bytes
float       # 4 byte IEEE
double      # 8 byte IEEE
string      # buffer & size

# Pointer to a different type
PTR<T>      # 64bit

# Structs can be defined
struct Person start
    int age
    string name
    Date birthday
end

struct Date start
    int day
    int month
    int year
end

# Structs can be accessed
Person p
p.name = "Steve"
print p.name



# Assign multiple variable at once using 'unpack'
# 'unpack' (ANY)->(N * T) N{targets}
var get_ABCD -> number number number number do
    return 10 11 12 13
end
unpack a b c d to get_ABCD
